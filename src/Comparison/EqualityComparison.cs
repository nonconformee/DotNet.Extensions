using System;
using System.Collections;
using System.Collections.Generic;




namespace RI.Utilities.Comparison
{
    /// <summary>
    ///     Implements an equality comparer based on an equality comparison function.
    /// </summary>
    /// <typeparam name="T"> The type of objects to compare for equality. </typeparam>
    /// <remarks>
    ///     <para>
    ///         This equality comparer can be used if an <see cref="IEqualityComparer{T}" /> or <see cref="IEqualityComparer" /> is required but equality comparison should be handled by a custom function or lambda expression.
    ///     </para>
    ///     <note type="important">
    ///         Be aware of the behaviour of <see cref="EqualityComparison{T}" /> regarding hash values.
    ///         See <see cref="EqualityComparison{T}(Func{T,T,bool})" /> and <see cref="EqualityComparison{T}(Func{T, T, bool}, Func{T, int})" /> for more details.
    ///     </note>
    /// </remarks>
    /// <threadsafety static="false" instance="false" />
    /// <example>
    ///     <code language="cs">
    ///  <![CDATA[
    ///  // create a list of integers
    ///  var numbers = new List<int> { 0, 1, 4, 5, 12 };
    /// 
    ///  // create the comparer, including a hash value calculation function
    ///  // what we do: two integers are considered the same if they have the same remainder when divided by 5
    ///  var comparer = new EqualityComparison<int>(
    ///      (x,y) => (x % 5) == (y % 5),
    ///      (obj) => obj % 5 );
    ///  
    ///  // lets use the comparer to check whether we have some numbers in the list or not
    ///  numbers.Contains(0, comparer); //returns "true" because of 0 in the list
    ///  numbers.Contains(1, comparer); //returns "true" because of 1 in the list
    ///  numbers.Contains(2, comparer); //returns "true" because of 12 in the list
    ///  numbers.Contains(3, comparer); //returns "false"
    ///  numbers.Contains(4, comparer); //returns "true" because of 4 in the list
    ///  numbers.Contains(5, comparer); //returns "true" because of 0 in the list
    ///  ]]>
    ///  </code>
    /// </example>
    public sealed class EqualityComparison <T> : IEqualityComparer<T>, IEqualityComparer
    {
        #region Instance Constructor/Destructor

        /// <summary>
        ///     Creates a new instance of <see cref="EqualityComparison{T}" />.
        /// </summary>
        /// <param name="comparer"> The function which is used to compare two objects of type <typeparamref name="T" />. </param>
        /// <remarks>
        ///     <para>
        ///         The <see cref="EqualityComparison{T}" /> created with this constructor uses the objects (of type <typeparamref name="T" />) own <see cref="object.GetHashCode" /> method for calculating hash values.
        ///     </para>
        ///     <para>
        ///         Therefore, the <see cref="EqualityComparison{T}" /> created with this constructor should not be used in scenarios where hash values are used, e.g. as the equality comparer of a <see cref="HashSet{T}" /> or <see cref="Dictionary{TKey, TValue}" />, if the hash value calculation of the objects own <see cref="object.GetHashCode" /> method does not correspond to the equality comparison performed by <paramref name="comparer" />.
        ///         If those do not correspond but it is still used for hash values, performance might be severly impacted or, depending on the usage of the hash values, other strange side-effects might occur.
        ///     </para>
        /// </remarks>
        /// <exception cref="ArgumentNullException"> <paramref name="comparer" /> is null. </exception>
        public EqualityComparison (Func<T, T, bool> comparer)
            : this(comparer, null) { }

        /// <summary>
        ///     Creates a new instance of <see cref="EqualityComparison{T}" />.
        /// </summary>
        /// <param name="comparer"> The function which is used to compare two objects of type <typeparamref name="T" />. </param>
        /// <param name="hasher"> The function which is used to get the hash value of an object of type <typeparamref name="T" />. Can be null to use the objects own <see cref="object.GetHashCode" /> method. </param>
        /// <remarks>
        ///     <para>
        ///         The <see cref="EqualityComparison{T}" /> created with this constructor uses the custom hash value function as specified by <paramref name="hasher" /> for calculating hash values.
        ///         This means that the hash value generated by <paramref name="hasher" /> must correspond to the equality comparison performed by <paramref name="comparer" />.
        ///     </para>
        ///     <para>
        ///         Therefore, the <see cref="EqualityComparison{T}" /> created with this constructor can be used in scenarios which uses hash values, e.g. as the equality comparer of a <see cref="HashSet{T}" /> or <see cref="Dictionary{TKey, TValue}" />.
        ///     </para>
        /// </remarks>
        /// <exception cref="ArgumentNullException"> <paramref name="comparer" /> is null. </exception>
        public EqualityComparison (Func<T, T, bool> comparer, Func<T, int> hasher)
        {
            if (comparer == null)
            {
                throw new ArgumentNullException(nameof(comparer));
            }

            this.Comparer = comparer;
            this.Hasher = hasher ?? (x => x == null ? 0 : x.GetHashCode());
        }

        #endregion




        #region Instance Properties/Indexer

        /// <summary>
        ///     Gets the function used to compare two objects.
        /// </summary>
        /// <value>
        ///     The function used to compare two objects.
        /// </value>
        public Func<T, T, bool> Comparer { get; }

        /// <summary>
        ///     Gets the function used to calculate the hash value of an object.
        /// </summary>
        /// <value>
        ///     The function used to calculate the hash value of an object.
        /// </value>
        /// <remarks>
        ///     <para>
        ///         This delegate always points to the function which eventually does the calculation of the hash value.
        ///         If the <see cref="EqualityComparison{T}" /> was constructed specifying a hash function (using the <see cref="EqualityComparison{T}(Func{T, T, bool}, Func{T, int})" /> constructor) the delegate points to that function, otherwise it points to an anonymous function which encapsulates <typeparamref name="T" />.<see cref="object.GetHashCode" />.
        ///     </para>
        /// </remarks>
        public Func<T, int> Hasher { get; }

        #endregion




        #region Interface: IEqualityComparer

        /// <inheritdoc cref="EqualityComparison{T}.Equals(T, T)" />
        /// <remarks>
        ///     <note type="note">
        ///         The return value is always false if one or both of <paramref name="x" /> and <paramref name="y" /> is null or not of type <typeparamref name="T" />.
        ///     </note>
        /// </remarks>
        bool IEqualityComparer.Equals (object x, object y)
        {
            if (!(x is T) || !(y is T))
            {
                return false;
            }

            return this.Equals((T)x, (T)y);
        }

        /// <inheritdoc cref="EqualityComparison{T}.GetHashCode(T)" />
        /// <remarks>
        ///     <note type="note">
        ///         The return value is always zero if <paramref name="obj" /> is null or not of type <typeparamref name="T" />.
        ///     </note>
        /// </remarks>
        int IEqualityComparer.GetHashCode (object obj)
        {
            if (!(obj is T))
            {
                return 0;
            }

            return this.GetHashCode((T)obj);
        }

        #endregion




        #region Interface: IEqualityComparer<T>

        /// <summary>
        ///     Compares two objects.
        /// </summary>
        /// <param name="x"> The first object to compare. </param>
        /// <param name="y"> The second object to compare </param>
        /// <returns>
        ///     true if both objects are considered equal, false otherwise.
        /// </returns>
        public bool Equals (T x, T y)
        {
            return this.Comparer(x, y);
        }

        /// <summary>
        ///     Gets the hash value of an object.
        /// </summary>
        /// <param name="obj"> The object. </param>
        /// <returns>
        ///     The hash value of an object.
        /// </returns>
        /// <remarks>
        ///     The hash value is calculated depending on how the <see cref="EqualityComparison{T}" /> was constructed, see <see cref="EqualityComparison{T}(Func{T, T, bool})" /> and <see cref="EqualityComparison{T}(Func{T, T, bool}, Func{T, int})" /> for more details.
        /// </remarks>
        public int GetHashCode (T obj)
        {
            return this.Hasher(obj);
        }

        #endregion
    }
}
